/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   Prog    ********************/
Prog::Prog(ListTopDef *p1)
{
  listtopdef_ = p1;

}

Prog::Prog(const Prog & other)
{
  listtopdef_ = other.listtopdef_->clone();

}

Prog &Prog::operator=(const Prog & other)
{
  Prog tmp(other);
  swap(tmp);
  return *this;
}

void Prog::swap(Prog & other)
{
  std::swap(listtopdef_, other.listtopdef_);

}

Prog::~Prog()
{
  delete(listtopdef_);

}

void Prog::accept(Visitor *v)
{
  v->visitProg(this);
}

Prog *Prog::clone() const
{
  return new Prog(*this);
}



/********************   FnDef    ********************/
FnDef::FnDef(Type *p1, Ident p2, ListArg *p3, Block *p4)
{
  type_ = p1;
  ident_ = p2;
  listarg_ = p3;
  block_ = p4;

}

FnDef::FnDef(const FnDef & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listarg_ = other.listarg_->clone();
  block_ = other.block_->clone();

}

FnDef &FnDef::operator=(const FnDef & other)
{
  FnDef tmp(other);
  swap(tmp);
  return *this;
}

void FnDef::swap(FnDef & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listarg_, other.listarg_);
  std::swap(block_, other.block_);

}

FnDef::~FnDef()
{
  delete(type_);
  delete(listarg_);
  delete(block_);

}

void FnDef::accept(Visitor *v)
{
  v->visitFnDef(this);
}

FnDef *FnDef::clone() const
{
  return new FnDef(*this);
}



/********************   ClassDef    ********************/
ClassDef::ClassDef(Ident p1, ClassBlock *p2)
{
  ident_ = p1;
  classblock_ = p2;

}

ClassDef::ClassDef(const ClassDef & other)
{
  ident_ = other.ident_;
  classblock_ = other.classblock_->clone();

}

ClassDef &ClassDef::operator=(const ClassDef & other)
{
  ClassDef tmp(other);
  swap(tmp);
  return *this;
}

void ClassDef::swap(ClassDef & other)
{
  std::swap(ident_, other.ident_);
  std::swap(classblock_, other.classblock_);

}

ClassDef::~ClassDef()
{
  delete(classblock_);

}

void ClassDef::accept(Visitor *v)
{
  v->visitClassDef(this);
}

ClassDef *ClassDef::clone() const
{
  return new ClassDef(*this);
}



/********************   ExtClassDef    ********************/
ExtClassDef::ExtClassDef(Ident p1, Ident p2, ClassBlock *p3)
{
  ident_1 = p1;
  ident_2 = p2;
  classblock_ = p3;

}

ExtClassDef::ExtClassDef(const ExtClassDef & other)
{
  ident_1 = other.ident_1;
  ident_2 = other.ident_2;
  classblock_ = other.classblock_->clone();

}

ExtClassDef &ExtClassDef::operator=(const ExtClassDef & other)
{
  ExtClassDef tmp(other);
  swap(tmp);
  return *this;
}

void ExtClassDef::swap(ExtClassDef & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(ident_2, other.ident_2);
  std::swap(classblock_, other.classblock_);

}

ExtClassDef::~ExtClassDef()
{
  delete(classblock_);

}

void ExtClassDef::accept(Visitor *v)
{
  v->visitExtClassDef(this);
}

ExtClassDef *ExtClassDef::clone() const
{
  return new ExtClassDef(*this);
}



/********************   Ar    ********************/
Ar::Ar(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

Ar::Ar(const Ar & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

Ar &Ar::operator=(const Ar & other)
{
  Ar tmp(other);
  swap(tmp);
  return *this;
}

void Ar::swap(Ar & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

Ar::~Ar()
{
  delete(type_);

}

void Ar::accept(Visitor *v)
{
  v->visitAr(this);
}

Ar *Ar::clone() const
{
  return new Ar(*this);
}



/********************   Bloc    ********************/
Bloc::Bloc(ListStmt *p1)
{
  liststmt_ = p1;

}

Bloc::Bloc(const Bloc & other)
{
  liststmt_ = other.liststmt_->clone();

}

Bloc &Bloc::operator=(const Bloc & other)
{
  Bloc tmp(other);
  swap(tmp);
  return *this;
}

void Bloc::swap(Bloc & other)
{
  std::swap(liststmt_, other.liststmt_);

}

Bloc::~Bloc()
{
  delete(liststmt_);

}

void Bloc::accept(Visitor *v)
{
  v->visitBloc(this);
}

Bloc *Bloc::clone() const
{
  return new Bloc(*this);
}



/********************   ClassBloc    ********************/
ClassBloc::ClassBloc(ListClassStmt *p1)
{
  listclassstmt_ = p1;

}

ClassBloc::ClassBloc(const ClassBloc & other)
{
  listclassstmt_ = other.listclassstmt_->clone();

}

ClassBloc &ClassBloc::operator=(const ClassBloc & other)
{
  ClassBloc tmp(other);
  swap(tmp);
  return *this;
}

void ClassBloc::swap(ClassBloc & other)
{
  std::swap(listclassstmt_, other.listclassstmt_);

}

ClassBloc::~ClassBloc()
{
  delete(listclassstmt_);

}

void ClassBloc::accept(Visitor *v)
{
  v->visitClassBloc(this);
}

ClassBloc *ClassBloc::clone() const
{
  return new ClassBloc(*this);
}



/********************   ClassEmpty    ********************/
ClassEmpty::ClassEmpty()
{

}

ClassEmpty::ClassEmpty(const ClassEmpty & other)
{

}

ClassEmpty &ClassEmpty::operator=(const ClassEmpty & other)
{
  ClassEmpty tmp(other);
  swap(tmp);
  return *this;
}

void ClassEmpty::swap(ClassEmpty & other)
{

}

ClassEmpty::~ClassEmpty()
{

}

void ClassEmpty::accept(Visitor *v)
{
  v->visitClassEmpty(this);
}

ClassEmpty *ClassEmpty::clone() const
{
  return new ClassEmpty(*this);
}



/********************   ClassDecl    ********************/
ClassDecl::ClassDecl(Type *p1, ListItem *p2)
{
  type_ = p1;
  listitem_ = p2;

}

ClassDecl::ClassDecl(const ClassDecl & other)
{
  type_ = other.type_->clone();
  listitem_ = other.listitem_->clone();

}

ClassDecl &ClassDecl::operator=(const ClassDecl & other)
{
  ClassDecl tmp(other);
  swap(tmp);
  return *this;
}

void ClassDecl::swap(ClassDecl & other)
{
  std::swap(type_, other.type_);
  std::swap(listitem_, other.listitem_);

}

ClassDecl::~ClassDecl()
{
  delete(type_);
  delete(listitem_);

}

void ClassDecl::accept(Visitor *v)
{
  v->visitClassDecl(this);
}

ClassDecl *ClassDecl::clone() const
{
  return new ClassDecl(*this);
}



/********************   ClassMethod    ********************/
ClassMethod::ClassMethod(Type *p1, Ident p2, ListArg *p3, Block *p4)
{
  type_ = p1;
  ident_ = p2;
  listarg_ = p3;
  block_ = p4;

}

ClassMethod::ClassMethod(const ClassMethod & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listarg_ = other.listarg_->clone();
  block_ = other.block_->clone();

}

ClassMethod &ClassMethod::operator=(const ClassMethod & other)
{
  ClassMethod tmp(other);
  swap(tmp);
  return *this;
}

void ClassMethod::swap(ClassMethod & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listarg_, other.listarg_);
  std::swap(block_, other.block_);

}

ClassMethod::~ClassMethod()
{
  delete(type_);
  delete(listarg_);
  delete(block_);

}

void ClassMethod::accept(Visitor *v)
{
  v->visitClassMethod(this);
}

ClassMethod *ClassMethod::clone() const
{
  return new ClassMethod(*this);
}



/********************   Empty    ********************/
Empty::Empty()
{

}

Empty::Empty(const Empty & other)
{

}

Empty &Empty::operator=(const Empty & other)
{
  Empty tmp(other);
  swap(tmp);
  return *this;
}

void Empty::swap(Empty & other)
{

}

Empty::~Empty()
{

}

void Empty::accept(Visitor *v)
{
  v->visitEmpty(this);
}

Empty *Empty::clone() const
{
  return new Empty(*this);
}



/********************   BStmt    ********************/
BStmt::BStmt(Block *p1)
{
  block_ = p1;

}

BStmt::BStmt(const BStmt & other)
{
  block_ = other.block_->clone();

}

BStmt &BStmt::operator=(const BStmt & other)
{
  BStmt tmp(other);
  swap(tmp);
  return *this;
}

void BStmt::swap(BStmt & other)
{
  std::swap(block_, other.block_);

}

BStmt::~BStmt()
{
  delete(block_);

}

void BStmt::accept(Visitor *v)
{
  v->visitBStmt(this);
}

BStmt *BStmt::clone() const
{
  return new BStmt(*this);
}



/********************   Decl    ********************/
Decl::Decl(Type *p1, ListItem *p2)
{
  type_ = p1;
  listitem_ = p2;

}

Decl::Decl(const Decl & other)
{
  type_ = other.type_->clone();
  listitem_ = other.listitem_->clone();

}

Decl &Decl::operator=(const Decl & other)
{
  Decl tmp(other);
  swap(tmp);
  return *this;
}

void Decl::swap(Decl & other)
{
  std::swap(type_, other.type_);
  std::swap(listitem_, other.listitem_);

}

Decl::~Decl()
{
  delete(type_);
  delete(listitem_);

}

void Decl::accept(Visitor *v)
{
  v->visitDecl(this);
}

Decl *Decl::clone() const
{
  return new Decl(*this);
}



/********************   Ass    ********************/
Ass::Ass(ExtIdent *p1, Expr *p2)
{
  extident_ = p1;
  expr_ = p2;

}

Ass::Ass(const Ass & other)
{
  extident_ = other.extident_->clone();
  expr_ = other.expr_->clone();

}

Ass &Ass::operator=(const Ass & other)
{
  Ass tmp(other);
  swap(tmp);
  return *this;
}

void Ass::swap(Ass & other)
{
  std::swap(extident_, other.extident_);
  std::swap(expr_, other.expr_);

}

Ass::~Ass()
{
  delete(extident_);
  delete(expr_);

}

void Ass::accept(Visitor *v)
{
  v->visitAss(this);
}

Ass *Ass::clone() const
{
  return new Ass(*this);
}



/********************   Incr    ********************/
Incr::Incr(ExtIdent *p1)
{
  extident_ = p1;

}

Incr::Incr(const Incr & other)
{
  extident_ = other.extident_->clone();

}

Incr &Incr::operator=(const Incr & other)
{
  Incr tmp(other);
  swap(tmp);
  return *this;
}

void Incr::swap(Incr & other)
{
  std::swap(extident_, other.extident_);

}

Incr::~Incr()
{
  delete(extident_);

}

void Incr::accept(Visitor *v)
{
  v->visitIncr(this);
}

Incr *Incr::clone() const
{
  return new Incr(*this);
}



/********************   Decr    ********************/
Decr::Decr(ExtIdent *p1)
{
  extident_ = p1;

}

Decr::Decr(const Decr & other)
{
  extident_ = other.extident_->clone();

}

Decr &Decr::operator=(const Decr & other)
{
  Decr tmp(other);
  swap(tmp);
  return *this;
}

void Decr::swap(Decr & other)
{
  std::swap(extident_, other.extident_);

}

Decr::~Decr()
{
  delete(extident_);

}

void Decr::accept(Visitor *v)
{
  v->visitDecr(this);
}

Decr *Decr::clone() const
{
  return new Decr(*this);
}



/********************   Ret    ********************/
Ret::Ret(Expr *p1)
{
  expr_ = p1;

}

Ret::Ret(const Ret & other)
{
  expr_ = other.expr_->clone();

}

Ret &Ret::operator=(const Ret & other)
{
  Ret tmp(other);
  swap(tmp);
  return *this;
}

void Ret::swap(Ret & other)
{
  std::swap(expr_, other.expr_);

}

Ret::~Ret()
{
  delete(expr_);

}

void Ret::accept(Visitor *v)
{
  v->visitRet(this);
}

Ret *Ret::clone() const
{
  return new Ret(*this);
}



/********************   VRet    ********************/
VRet::VRet()
{

}

VRet::VRet(const VRet & other)
{

}

VRet &VRet::operator=(const VRet & other)
{
  VRet tmp(other);
  swap(tmp);
  return *this;
}

void VRet::swap(VRet & other)
{

}

VRet::~VRet()
{

}

void VRet::accept(Visitor *v)
{
  v->visitVRet(this);
}

VRet *VRet::clone() const
{
  return new VRet(*this);
}



/********************   Cond    ********************/
Cond::Cond(Expr *p1, Stmt *p2)
{
  expr_ = p1;
  stmt_ = p2;

}

Cond::Cond(const Cond & other)
{
  expr_ = other.expr_->clone();
  stmt_ = other.stmt_->clone();

}

Cond &Cond::operator=(const Cond & other)
{
  Cond tmp(other);
  swap(tmp);
  return *this;
}

void Cond::swap(Cond & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_, other.stmt_);

}

Cond::~Cond()
{
  delete(expr_);
  delete(stmt_);

}

void Cond::accept(Visitor *v)
{
  v->visitCond(this);
}

Cond *Cond::clone() const
{
  return new Cond(*this);
}



/********************   CondElse    ********************/
CondElse::CondElse(Expr *p1, Stmt *p2, Stmt *p3)
{
  expr_ = p1;
  stmt_1 = p2;
  stmt_2 = p3;

}

CondElse::CondElse(const CondElse & other)
{
  expr_ = other.expr_->clone();
  stmt_1 = other.stmt_1->clone();
  stmt_2 = other.stmt_2->clone();

}

CondElse &CondElse::operator=(const CondElse & other)
{
  CondElse tmp(other);
  swap(tmp);
  return *this;
}

void CondElse::swap(CondElse & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_1, other.stmt_1);
  std::swap(stmt_2, other.stmt_2);

}

CondElse::~CondElse()
{
  delete(expr_);
  delete(stmt_1);
  delete(stmt_2);

}

void CondElse::accept(Visitor *v)
{
  v->visitCondElse(this);
}

CondElse *CondElse::clone() const
{
  return new CondElse(*this);
}



/********************   While    ********************/
While::While(Expr *p1, Stmt *p2)
{
  expr_ = p1;
  stmt_ = p2;

}

While::While(const While & other)
{
  expr_ = other.expr_->clone();
  stmt_ = other.stmt_->clone();

}

While &While::operator=(const While & other)
{
  While tmp(other);
  swap(tmp);
  return *this;
}

void While::swap(While & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_, other.stmt_);

}

While::~While()
{
  delete(expr_);
  delete(stmt_);

}

void While::accept(Visitor *v)
{
  v->visitWhile(this);
}

While *While::clone() const
{
  return new While(*this);
}



/********************   For    ********************/
For::For(Type *p1, Ident p2, ExtIdent *p3, Stmt *p4)
{
  type_ = p1;
  ident_ = p2;
  extident_ = p3;
  stmt_ = p4;

}

For::For(const For & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  extident_ = other.extident_->clone();
  stmt_ = other.stmt_->clone();

}

For &For::operator=(const For & other)
{
  For tmp(other);
  swap(tmp);
  return *this;
}

void For::swap(For & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(extident_, other.extident_);
  std::swap(stmt_, other.stmt_);

}

For::~For()
{
  delete(type_);
  delete(extident_);
  delete(stmt_);

}

void For::accept(Visitor *v)
{
  v->visitFor(this);
}

For *For::clone() const
{
  return new For(*this);
}



/********************   SExp    ********************/
SExp::SExp(Expr *p1)
{
  expr_ = p1;

}

SExp::SExp(const SExp & other)
{
  expr_ = other.expr_->clone();

}

SExp &SExp::operator=(const SExp & other)
{
  SExp tmp(other);
  swap(tmp);
  return *this;
}

void SExp::swap(SExp & other)
{
  std::swap(expr_, other.expr_);

}

SExp::~SExp()
{
  delete(expr_);

}

void SExp::accept(Visitor *v)
{
  v->visitSExp(this);
}

SExp *SExp::clone() const
{
  return new SExp(*this);
}



/********************   NoInit    ********************/
NoInit::NoInit(Ident p1)
{
  ident_ = p1;

}

NoInit::NoInit(const NoInit & other)
{
  ident_ = other.ident_;

}

NoInit &NoInit::operator=(const NoInit & other)
{
  NoInit tmp(other);
  swap(tmp);
  return *this;
}

void NoInit::swap(NoInit & other)
{
  std::swap(ident_, other.ident_);

}

NoInit::~NoInit()
{

}

void NoInit::accept(Visitor *v)
{
  v->visitNoInit(this);
}

NoInit *NoInit::clone() const
{
  return new NoInit(*this);
}



/********************   Init    ********************/
Init::Init(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

Init::Init(const Init & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

Init &Init::operator=(const Init & other)
{
  Init tmp(other);
  swap(tmp);
  return *this;
}

void Init::swap(Init & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

Init::~Init()
{
  delete(expr_);

}

void Init::accept(Visitor *v)
{
  v->visitInit(this);
}

Init *Init::clone() const
{
  return new Init(*this);
}



/********************   Id    ********************/
Id::Id(Ident p1)
{
  ident_ = p1;

}

Id::Id(const Id & other)
{
  ident_ = other.ident_;

}

Id &Id::operator=(const Id & other)
{
  Id tmp(other);
  swap(tmp);
  return *this;
}

void Id::swap(Id & other)
{
  std::swap(ident_, other.ident_);

}

Id::~Id()
{

}

void Id::accept(Visitor *v)
{
  v->visitId(this);
}

Id *Id::clone() const
{
  return new Id(*this);
}



/********************   ArrId    ********************/
ArrId::ArrId(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

ArrId::ArrId(const ArrId & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

ArrId &ArrId::operator=(const ArrId & other)
{
  ArrId tmp(other);
  swap(tmp);
  return *this;
}

void ArrId::swap(ArrId & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

ArrId::~ArrId()
{
  delete(expr_);

}

void ArrId::accept(Visitor *v)
{
  v->visitArrId(this);
}

ArrId *ArrId::clone() const
{
  return new ArrId(*this);
}



/********************   AttrId    ********************/
AttrId::AttrId(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

AttrId::AttrId(const AttrId & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

AttrId &AttrId::operator=(const AttrId & other)
{
  AttrId tmp(other);
  swap(tmp);
  return *this;
}

void AttrId::swap(AttrId & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

AttrId::~AttrId()
{
  delete(expr_1);
  delete(expr_2);

}

void AttrId::accept(Visitor *v)
{
  v->visitAttrId(this);
}

AttrId *AttrId::clone() const
{
  return new AttrId(*this);
}



/********************   Int    ********************/
Int::Int()
{

}

Int::Int(const Int & other)
{

}

Int &Int::operator=(const Int & other)
{
  Int tmp(other);
  swap(tmp);
  return *this;
}

void Int::swap(Int & other)
{

}

Int::~Int()
{

}

void Int::accept(Visitor *v)
{
  v->visitInt(this);
}

Int *Int::clone() const
{
  return new Int(*this);
}



/********************   Str    ********************/
Str::Str()
{

}

Str::Str(const Str & other)
{

}

Str &Str::operator=(const Str & other)
{
  Str tmp(other);
  swap(tmp);
  return *this;
}

void Str::swap(Str & other)
{

}

Str::~Str()
{

}

void Str::accept(Visitor *v)
{
  v->visitStr(this);
}

Str *Str::clone() const
{
  return new Str(*this);
}



/********************   Bool    ********************/
Bool::Bool()
{

}

Bool::Bool(const Bool & other)
{

}

Bool &Bool::operator=(const Bool & other)
{
  Bool tmp(other);
  swap(tmp);
  return *this;
}

void Bool::swap(Bool & other)
{

}

Bool::~Bool()
{

}

void Bool::accept(Visitor *v)
{
  v->visitBool(this);
}

Bool *Bool::clone() const
{
  return new Bool(*this);
}



/********************   Void    ********************/
Void::Void()
{

}

Void::Void(const Void & other)
{

}

Void &Void::operator=(const Void & other)
{
  Void tmp(other);
  swap(tmp);
  return *this;
}

void Void::swap(Void & other)
{

}

Void::~Void()
{

}

void Void::accept(Visitor *v)
{
  v->visitVoid(this);
}

Void *Void::clone() const
{
  return new Void(*this);
}



/********************   Primitive    ********************/
Primitive::Primitive(PrimType *p1)
{
  primtype_ = p1;

}

Primitive::Primitive(const Primitive & other)
{
  primtype_ = other.primtype_->clone();

}

Primitive &Primitive::operator=(const Primitive & other)
{
  Primitive tmp(other);
  swap(tmp);
  return *this;
}

void Primitive::swap(Primitive & other)
{
  std::swap(primtype_, other.primtype_);

}

Primitive::~Primitive()
{
  delete(primtype_);

}

void Primitive::accept(Visitor *v)
{
  v->visitPrimitive(this);
}

Primitive *Primitive::clone() const
{
  return new Primitive(*this);
}



/********************   ObjectType    ********************/
ObjectType::ObjectType(Ident p1)
{
  ident_ = p1;

}

ObjectType::ObjectType(const ObjectType & other)
{
  ident_ = other.ident_;

}

ObjectType &ObjectType::operator=(const ObjectType & other)
{
  ObjectType tmp(other);
  swap(tmp);
  return *this;
}

void ObjectType::swap(ObjectType & other)
{
  std::swap(ident_, other.ident_);

}

ObjectType::~ObjectType()
{

}

void ObjectType::accept(Visitor *v)
{
  v->visitObjectType(this);
}

ObjectType *ObjectType::clone() const
{
  return new ObjectType(*this);
}



/********************   Array    ********************/
Array::Array(Type *p1)
{
  type_ = p1;

}

Array::Array(const Array & other)
{
  type_ = other.type_->clone();

}

Array &Array::operator=(const Array & other)
{
  Array tmp(other);
  swap(tmp);
  return *this;
}

void Array::swap(Array & other)
{
  std::swap(type_, other.type_);

}

Array::~Array()
{
  delete(type_);

}

void Array::accept(Visitor *v)
{
  v->visitArray(this);
}

Array *Array::clone() const
{
  return new Array(*this);
}



/********************   Fun    ********************/
Fun::Fun(Type *p1, ListType *p2)
{
  type_ = p1;
  listtype_ = p2;

}

Fun::Fun(const Fun & other)
{
  type_ = other.type_->clone();
  listtype_ = other.listtype_->clone();

}

Fun &Fun::operator=(const Fun & other)
{
  Fun tmp(other);
  swap(tmp);
  return *this;
}

void Fun::swap(Fun & other)
{
  std::swap(type_, other.type_);
  std::swap(listtype_, other.listtype_);

}

Fun::~Fun()
{
  delete(type_);
  delete(listtype_);

}

void Fun::accept(Visitor *v)
{
  v->visitFun(this);
}

Fun *Fun::clone() const
{
  return new Fun(*this);
}



/********************   ECast    ********************/
ECast::ECast(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

ECast::ECast(const ECast & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

ECast &ECast::operator=(const ECast & other)
{
  ECast tmp(other);
  swap(tmp);
  return *this;
}

void ECast::swap(ECast & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

ECast::~ECast()
{
  delete(expr_);

}

void ECast::accept(Visitor *v)
{
  v->visitECast(this);
}

ECast *ECast::clone() const
{
  return new ECast(*this);
}



/********************   ECastPrim    ********************/
ECastPrim::ECastPrim(PrimType *p1, Expr *p2)
{
  primtype_ = p1;
  expr_ = p2;

}

ECastPrim::ECastPrim(const ECastPrim & other)
{
  primtype_ = other.primtype_->clone();
  expr_ = other.expr_->clone();

}

ECastPrim &ECastPrim::operator=(const ECastPrim & other)
{
  ECastPrim tmp(other);
  swap(tmp);
  return *this;
}

void ECastPrim::swap(ECastPrim & other)
{
  std::swap(primtype_, other.primtype_);
  std::swap(expr_, other.expr_);

}

ECastPrim::~ECastPrim()
{
  delete(primtype_);
  delete(expr_);

}

void ECastPrim::accept(Visitor *v)
{
  v->visitECastPrim(this);
}

ECastPrim *ECastPrim::clone() const
{
  return new ECastPrim(*this);
}



/********************   ENewObject    ********************/
ENewObject::ENewObject(Ident p1)
{
  ident_ = p1;

}

ENewObject::ENewObject(const ENewObject & other)
{
  ident_ = other.ident_;

}

ENewObject &ENewObject::operator=(const ENewObject & other)
{
  ENewObject tmp(other);
  swap(tmp);
  return *this;
}

void ENewObject::swap(ENewObject & other)
{
  std::swap(ident_, other.ident_);

}

ENewObject::~ENewObject()
{

}

void ENewObject::accept(Visitor *v)
{
  v->visitENewObject(this);
}

ENewObject *ENewObject::clone() const
{
  return new ENewObject(*this);
}



/********************   ENewArr    ********************/
ENewArr::ENewArr(Type *p1, Expr *p2)
{
  type_ = p1;
  expr_ = p2;

}

ENewArr::ENewArr(const ENewArr & other)
{
  type_ = other.type_->clone();
  expr_ = other.expr_->clone();

}

ENewArr &ENewArr::operator=(const ENewArr & other)
{
  ENewArr tmp(other);
  swap(tmp);
  return *this;
}

void ENewArr::swap(ENewArr & other)
{
  std::swap(type_, other.type_);
  std::swap(expr_, other.expr_);

}

ENewArr::~ENewArr()
{
  delete(type_);
  delete(expr_);

}

void ENewArr::accept(Visitor *v)
{
  v->visitENewArr(this);
}

ENewArr *ENewArr::clone() const
{
  return new ENewArr(*this);
}



/********************   ENull    ********************/
ENull::ENull()
{

}

ENull::ENull(const ENull & other)
{

}

ENull &ENull::operator=(const ENull & other)
{
  ENull tmp(other);
  swap(tmp);
  return *this;
}

void ENull::swap(ENull & other)
{

}

ENull::~ENull()
{

}

void ENull::accept(Visitor *v)
{
  v->visitENull(this);
}

ENull *ENull::clone() const
{
  return new ENull(*this);
}



/********************   EObject    ********************/
EObject::EObject(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EObject::EObject(const EObject & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EObject &EObject::operator=(const EObject & other)
{
  EObject tmp(other);
  swap(tmp);
  return *this;
}

void EObject::swap(EObject & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EObject::~EObject()
{
  delete(expr_1);
  delete(expr_2);

}

void EObject::accept(Visitor *v)
{
  v->visitEObject(this);
}

EObject *EObject::clone() const
{
  return new EObject(*this);
}



/********************   EArr    ********************/
EArr::EArr(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

EArr::EArr(const EArr & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

EArr &EArr::operator=(const EArr & other)
{
  EArr tmp(other);
  swap(tmp);
  return *this;
}

void EArr::swap(EArr & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

EArr::~EArr()
{
  delete(expr_);

}

void EArr::accept(Visitor *v)
{
  v->visitEArr(this);
}

EArr *EArr::clone() const
{
  return new EArr(*this);
}



/********************   EVar    ********************/
EVar::EVar(Ident p1)
{
  ident_ = p1;

}

EVar::EVar(const EVar & other)
{
  ident_ = other.ident_;

}

EVar &EVar::operator=(const EVar & other)
{
  EVar tmp(other);
  swap(tmp);
  return *this;
}

void EVar::swap(EVar & other)
{
  std::swap(ident_, other.ident_);

}

EVar::~EVar()
{

}

void EVar::accept(Visitor *v)
{
  v->visitEVar(this);
}

EVar *EVar::clone() const
{
  return new EVar(*this);
}



/********************   ELitInt    ********************/
ELitInt::ELitInt(Integer p1)
{
  integer_ = p1;

}

ELitInt::ELitInt(const ELitInt & other)
{
  integer_ = other.integer_;

}

ELitInt &ELitInt::operator=(const ELitInt & other)
{
  ELitInt tmp(other);
  swap(tmp);
  return *this;
}

void ELitInt::swap(ELitInt & other)
{
  std::swap(integer_, other.integer_);

}

ELitInt::~ELitInt()
{

}

void ELitInt::accept(Visitor *v)
{
  v->visitELitInt(this);
}

ELitInt *ELitInt::clone() const
{
  return new ELitInt(*this);
}



/********************   ELitTrue    ********************/
ELitTrue::ELitTrue()
{

}

ELitTrue::ELitTrue(const ELitTrue & other)
{

}

ELitTrue &ELitTrue::operator=(const ELitTrue & other)
{
  ELitTrue tmp(other);
  swap(tmp);
  return *this;
}

void ELitTrue::swap(ELitTrue & other)
{

}

ELitTrue::~ELitTrue()
{

}

void ELitTrue::accept(Visitor *v)
{
  v->visitELitTrue(this);
}

ELitTrue *ELitTrue::clone() const
{
  return new ELitTrue(*this);
}



/********************   ELitFalse    ********************/
ELitFalse::ELitFalse()
{

}

ELitFalse::ELitFalse(const ELitFalse & other)
{

}

ELitFalse &ELitFalse::operator=(const ELitFalse & other)
{
  ELitFalse tmp(other);
  swap(tmp);
  return *this;
}

void ELitFalse::swap(ELitFalse & other)
{

}

ELitFalse::~ELitFalse()
{

}

void ELitFalse::accept(Visitor *v)
{
  v->visitELitFalse(this);
}

ELitFalse *ELitFalse::clone() const
{
  return new ELitFalse(*this);
}



/********************   EApp    ********************/
EApp::EApp(Ident p1, ListExpr *p2)
{
  ident_ = p1;
  listexpr_ = p2;

}

EApp::EApp(const EApp & other)
{
  ident_ = other.ident_;
  listexpr_ = other.listexpr_->clone();

}

EApp &EApp::operator=(const EApp & other)
{
  EApp tmp(other);
  swap(tmp);
  return *this;
}

void EApp::swap(EApp & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexpr_, other.listexpr_);

}

EApp::~EApp()
{
  delete(listexpr_);

}

void EApp::accept(Visitor *v)
{
  v->visitEApp(this);
}

EApp *EApp::clone() const
{
  return new EApp(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   Neg    ********************/
Neg::Neg(Expr *p1)
{
  expr_ = p1;

}

Neg::Neg(const Neg & other)
{
  expr_ = other.expr_->clone();

}

Neg &Neg::operator=(const Neg & other)
{
  Neg tmp(other);
  swap(tmp);
  return *this;
}

void Neg::swap(Neg & other)
{
  std::swap(expr_, other.expr_);

}

Neg::~Neg()
{
  delete(expr_);

}

void Neg::accept(Visitor *v)
{
  v->visitNeg(this);
}

Neg *Neg::clone() const
{
  return new Neg(*this);
}



/********************   Not    ********************/
Not::Not(Expr *p1)
{
  expr_ = p1;

}

Not::Not(const Not & other)
{
  expr_ = other.expr_->clone();

}

Not &Not::operator=(const Not & other)
{
  Not tmp(other);
  swap(tmp);
  return *this;
}

void Not::swap(Not & other)
{
  std::swap(expr_, other.expr_);

}

Not::~Not()
{
  delete(expr_);

}

void Not::accept(Visitor *v)
{
  v->visitNot(this);
}

Not *Not::clone() const
{
  return new Not(*this);
}



/********************   EMul    ********************/
EMul::EMul(Expr *p1, MulOp *p2, Expr *p3)
{
  expr_1 = p1;
  mulop_ = p2;
  expr_2 = p3;

}

EMul::EMul(const EMul & other)
{
  expr_1 = other.expr_1->clone();
  mulop_ = other.mulop_->clone();
  expr_2 = other.expr_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(mulop_, other.mulop_);
  std::swap(expr_2, other.expr_2);

}

EMul::~EMul()
{
  delete(expr_1);
  delete(mulop_);
  delete(expr_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Expr *p1, AddOp *p2, Expr *p3)
{
  expr_1 = p1;
  addop_ = p2;
  expr_2 = p3;

}

EAdd::EAdd(const EAdd & other)
{
  expr_1 = other.expr_1->clone();
  addop_ = other.addop_->clone();
  expr_2 = other.expr_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(addop_, other.addop_);
  std::swap(expr_2, other.expr_2);

}

EAdd::~EAdd()
{
  delete(expr_1);
  delete(addop_);
  delete(expr_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ERel    ********************/
ERel::ERel(Expr *p1, RelOp *p2, Expr *p3)
{
  expr_1 = p1;
  relop_ = p2;
  expr_2 = p3;

}

ERel::ERel(const ERel & other)
{
  expr_1 = other.expr_1->clone();
  relop_ = other.relop_->clone();
  expr_2 = other.expr_2->clone();

}

ERel &ERel::operator=(const ERel & other)
{
  ERel tmp(other);
  swap(tmp);
  return *this;
}

void ERel::swap(ERel & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(relop_, other.relop_);
  std::swap(expr_2, other.expr_2);

}

ERel::~ERel()
{
  delete(expr_1);
  delete(relop_);
  delete(expr_2);

}

void ERel::accept(Visitor *v)
{
  v->visitERel(this);
}

ERel *ERel::clone() const
{
  return new ERel(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EAnd::~EAnd()
{
  delete(expr_1);
  delete(expr_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EOr::EOr(const EOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EOr::~EOr()
{
  delete(expr_1);
  delete(expr_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   Plus    ********************/
Plus::Plus()
{

}

Plus::Plus(const Plus & other)
{

}

Plus &Plus::operator=(const Plus & other)
{
  Plus tmp(other);
  swap(tmp);
  return *this;
}

void Plus::swap(Plus & other)
{

}

Plus::~Plus()
{

}

void Plus::accept(Visitor *v)
{
  v->visitPlus(this);
}

Plus *Plus::clone() const
{
  return new Plus(*this);
}



/********************   Minus    ********************/
Minus::Minus()
{

}

Minus::Minus(const Minus & other)
{

}

Minus &Minus::operator=(const Minus & other)
{
  Minus tmp(other);
  swap(tmp);
  return *this;
}

void Minus::swap(Minus & other)
{

}

Minus::~Minus()
{

}

void Minus::accept(Visitor *v)
{
  v->visitMinus(this);
}

Minus *Minus::clone() const
{
  return new Minus(*this);
}



/********************   Times    ********************/
Times::Times()
{

}

Times::Times(const Times & other)
{

}

Times &Times::operator=(const Times & other)
{
  Times tmp(other);
  swap(tmp);
  return *this;
}

void Times::swap(Times & other)
{

}

Times::~Times()
{

}

void Times::accept(Visitor *v)
{
  v->visitTimes(this);
}

Times *Times::clone() const
{
  return new Times(*this);
}



/********************   Div    ********************/
Div::Div()
{

}

Div::Div(const Div & other)
{

}

Div &Div::operator=(const Div & other)
{
  Div tmp(other);
  swap(tmp);
  return *this;
}

void Div::swap(Div & other)
{

}

Div::~Div()
{

}

void Div::accept(Visitor *v)
{
  v->visitDiv(this);
}

Div *Div::clone() const
{
  return new Div(*this);
}



/********************   Mod    ********************/
Mod::Mod()
{

}

Mod::Mod(const Mod & other)
{

}

Mod &Mod::operator=(const Mod & other)
{
  Mod tmp(other);
  swap(tmp);
  return *this;
}

void Mod::swap(Mod & other)
{

}

Mod::~Mod()
{

}

void Mod::accept(Visitor *v)
{
  v->visitMod(this);
}

Mod *Mod::clone() const
{
  return new Mod(*this);
}



/********************   LTH    ********************/
LTH::LTH()
{

}

LTH::LTH(const LTH & other)
{

}

LTH &LTH::operator=(const LTH & other)
{
  LTH tmp(other);
  swap(tmp);
  return *this;
}

void LTH::swap(LTH & other)
{

}

LTH::~LTH()
{

}

void LTH::accept(Visitor *v)
{
  v->visitLTH(this);
}

LTH *LTH::clone() const
{
  return new LTH(*this);
}



/********************   LE    ********************/
LE::LE()
{

}

LE::LE(const LE & other)
{

}

LE &LE::operator=(const LE & other)
{
  LE tmp(other);
  swap(tmp);
  return *this;
}

void LE::swap(LE & other)
{

}

LE::~LE()
{

}

void LE::accept(Visitor *v)
{
  v->visitLE(this);
}

LE *LE::clone() const
{
  return new LE(*this);
}



/********************   GTH    ********************/
GTH::GTH()
{

}

GTH::GTH(const GTH & other)
{

}

GTH &GTH::operator=(const GTH & other)
{
  GTH tmp(other);
  swap(tmp);
  return *this;
}

void GTH::swap(GTH & other)
{

}

GTH::~GTH()
{

}

void GTH::accept(Visitor *v)
{
  v->visitGTH(this);
}

GTH *GTH::clone() const
{
  return new GTH(*this);
}



/********************   GE    ********************/
GE::GE()
{

}

GE::GE(const GE & other)
{

}

GE &GE::operator=(const GE & other)
{
  GE tmp(other);
  swap(tmp);
  return *this;
}

void GE::swap(GE & other)
{

}

GE::~GE()
{

}

void GE::accept(Visitor *v)
{
  v->visitGE(this);
}

GE *GE::clone() const
{
  return new GE(*this);
}



/********************   EQU    ********************/
EQU::EQU()
{

}

EQU::EQU(const EQU & other)
{

}

EQU &EQU::operator=(const EQU & other)
{
  EQU tmp(other);
  swap(tmp);
  return *this;
}

void EQU::swap(EQU & other)
{

}

EQU::~EQU()
{

}

void EQU::accept(Visitor *v)
{
  v->visitEQU(this);
}

EQU *EQU::clone() const
{
  return new EQU(*this);
}



/********************   NE    ********************/
NE::NE()
{

}

NE::NE(const NE & other)
{

}

NE &NE::operator=(const NE & other)
{
  NE tmp(other);
  swap(tmp);
  return *this;
}

void NE::swap(NE & other)
{

}

NE::~NE()
{

}

void NE::accept(Visitor *v)
{
  v->visitNE(this);
}

NE *NE::clone() const
{
  return new NE(*this);
}




/********************   ListTopDef    ********************/

void ListTopDef::accept(Visitor *v)
{
  v->visitListTopDef(this);
}

ListTopDef *ListTopDef::clone() const
{
  return new ListTopDef(*this);
}

ListTopDef* consListTopDef(TopDef* x, ListTopDef* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListArg    ********************/

void ListArg::accept(Visitor *v)
{
  v->visitListArg(this);
}

ListArg *ListArg::clone() const
{
  return new ListArg(*this);
}

ListArg* consListArg(Arg* x, ListArg* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListClassStmt    ********************/

void ListClassStmt::accept(Visitor *v)
{
  v->visitListClassStmt(this);
}

ListClassStmt *ListClassStmt::clone() const
{
  return new ListClassStmt(*this);
}

ListClassStmt* consListClassStmt(ClassStmt* x, ListClassStmt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStmt    ********************/

void ListStmt::accept(Visitor *v)
{
  v->visitListStmt(this);
}

ListStmt *ListStmt::clone() const
{
  return new ListStmt(*this);
}

ListStmt* consListStmt(Stmt* x, ListStmt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListItem    ********************/

void ListItem::accept(Visitor *v)
{
  v->visitListItem(this);
}

ListItem *ListItem::clone() const
{
  return new ListItem(*this);
}

ListItem* consListItem(Item* x, ListItem* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListType    ********************/

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}

ListType *ListType::clone() const
{
  return new ListType(*this);
}

ListType* consListType(Type* x, ListType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExpr    ********************/

void ListExpr::accept(Visitor *v)
{
  v->visitListExpr(this);
}

ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}

ListExpr* consListExpr(Expr* x, ListExpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}





